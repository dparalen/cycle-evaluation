\documentclass[12pt,oneside,draft]{fithesis}
\usepackage[plainpages=false, pdfpagelabels]{hyperref}
%\usepackage{amssym}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{paralist}
\usepackage{color}

%
\newcommand{\ltl}{\textsc{ltl}~}
\newcommand{\Next}{\emph{Next}~}
\newcommand{\mM}{\mathcal{M}}
\newcommand{\mD}{\mathcal{D}}
\newcommand{\mC}{\mathcal{C}}
\newcommand{\mI}{\mathcal{I}}
\newcommand{\mE}{\mathcal{E}}
\newcommand{\mS}{\mathcal{S}}
\newcommand{\mReal}{\mathbb{R}}
\newcommand{\mNatural}{\mathbb{N}}
\newcommand{\mTime}{\mathbb{T}}
\newcommand{\dStateVariables}{$Y'=\{y'_0,y'_1,\dotsc,y'_n\},n\in\mNatural$}
\newcommand{\dAtomicPropositionsI}{$AP_i=\{a_{i,0},a_{i,1},\dotsc,a_{i,m}\},m\in\mNatural$}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bG}{\mathbf{G}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bR}{\mathbf{R}}
\newcommand{\bA}{\mathbf{A}}
\newcommand{\bE}{\mathbf{E}}
%
\newtheorem{mydef}{Definition}
\newtheorem{mylemma}{Lemma}
%
\hyphenation{Kri-p-ke}
\hyphenation{boun-ded}
%\hyphenation{pro-po-si-t-ion}
%
\thesistitle{Simulation Analysis of Large-scale Dynamic Systems}
\thesissubtitle{Bachelors Thesis}
\thesisstudent{Milan Kov\'{a}\v{c}ik}
\thesiswoman{false}
\thesisfaculty{fi}
\thesisyear{Fall 2011}
\thesislang{en}
\thesisadvisor{David \v{S}afr\'{a}nek}
%
\input{transfig}
\begin{document}

\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

%\begin{ThesisThanks}
%\end{ThesisThanks}

%\begin{ThesisAbstract}
%\end{ThesisAbstract}

%\begin{ThesisKeyWords}
%\end{ThesisKeyWords}

\MainMatter
\tableofcontents
\chapter{Introduction}
%\section{Framework Description}
The framework main task is to select traces starting at the seeds of
initial conditions that fulfil given \ltl specification over the time
period provided. Therefore two main components are identified:
\em simulation and model checking\rm{}.
In the framework, the output of the simulation is processed by the
model checking component to verify the LTL formula validity of
a particular trace. Having verified all traces of the initial conditions
set, the framework marks the seeds fulfiling the formula to provide
the user with an output. User then could refine her initial conditions
specification for further system evaluation. In this fashion, the user
might iterate till a~subjective satisfaction with the system evaluation
was reached.

In such a~session, the framework provides simulation traces of the
system observed over the time specified. The simulation being rather
straightforward, a~common integrator -- such as provided in the
\textsc{lsoda} \cite{lsoda} package -- may be used.
An output in this case is an approximation of a~continuous trajectory
of the dynamic system.

\chapter{Background}
Considering the model checking and simulation topics, this section
introduces necessary concepts utilized troughout the text.

\section{Trace}
Here, a~trace $\pi$ represents result of either a~dynamic system
evolution over a~range of time\cite{sven}\cite{pospisil} approximated by
a~numeric method or a~result of any other kind of experiment.
Both sources describing values of concentrations of $n$ state variables,
the domain considered is~$\mReal_{+}^n$.

\begin{mydef}[Trace]
Let $n\in\mNatural$ be the number of state variables of a~system,
then:
\begin{inparaenum}[\upshape a\itshape)]
\item a~sequence $\pi=p_0,p_1,\dotsc$ of tuples
$p_i\in\mReal_{+}^n$ is caled a~trace;
\item single element $p_i=\pi(i)$ of a~trace $\pi$ is
called a~point;
\item the first point in a~trace $p_0=\pi(0)$ is called
a~seed;
\item a suffix of points $p_i,p_{i+1},\dotsc$ of a~trace is
denoted $\pi^i$;
\item a~fact that $p_i$ predeceases $p_{i+1}$ in a~trace is
denoted~$p_i\rightarrow p_{i+1}$.
\end{inparaenum}
\end{mydef}

As far as dynamic systems are concerned, their evolution approximation
obtained as a~result of a~numerical method is always \emph{discrete and
finite}. The same holds for sampled real-life system experiments.
However, an infinite sequence is considered wherever formal reasons
require it.

\section{Trace Properties}
Real system traces may be either \emph{divergent} -- in which case
a~system generates just an infinite sequence of points -- or
\emph{convergent}. In~the convergent case, two situations are possible;
a~point \emph{equilibrium} and a~\emph{limit cycle}. A~system may reach
the point equilibrium either asymptotically or sliding downwards
a~spiral. These situations are depicted in figure \ref{fig:trace:kinds}.

In addition, equilibrium and limit cycle are traces in which
points repeat ad infinitum and the trace contains exactly one loop.
Hence the loop definition.
\begin{mydef}[K-Loop]
For $l\leq k;l,k\in\mNatural_0$ a~trace $\pi$ is called a~$(k,l)$-loop
if $\pi(k)\rightarrow\pi(l)$ and
$\pi=p_0,\dotsc,\overline{p_{l},\dotsc,p_{k},}$
A~$(k,l)$-loop may be called simply a~$k$-loop as well or, if $l=k$,
a~self-loop.
\end{mydef}
\begin{figure}
\label{fig:trace:kinds}
\caption{Trace Kinds}
\end{figure}
A~$k$-loop system trace may express both \emph{liveness}
and \emph{reachability} properties. These could be \emph{attractor} or
\emph{invariance}\cite{rizk}. On the other hand, only reachability
properties can be verified over a~divergent trace. These might contain
\emph{inevitability} or \emph{response}\cite{rizk}. What these trace
properties have in common is they can be expressed as \ltl formulae
over real-based constraints\cite{sven}. Therefore, the \ltl semantics
is introduced.

\subsection{LTL Semantics}
\subsubsection*{Kripke Structure}
A~Kripke structure is a~common and satisfying way of modeling a~system,
especially for the purpose of the model validation\cite{clarke}.
\begin{mydef}[Kripke Structure]
Let ${AP}$ be a set of atomic propositions.
A~Kripke structure\cite{clarke} $M$ over $AP$ is a~tuple
$M=(S, S_0, R, L)$ where
\begin{inparaenum}[\upshape a\itshape)]
	\item{}$S$ is~a finite set of states;
	\item{}$S_0\subseteq{}S$ is the set of initial states;
	\item{}$R\subseteq{}S\times{}S$ is a~total transition relation; and
	\item{}$L:S\rightarrow{}2^{AP}$ is a~function that labels each state
		with a subset of atomic propositions valid in that state.
\end{inparaenum}
\end{mydef}
In the text, real-constraint atomic propositions are considered.
An example of such a~constraint could be
$a\equiv x_i \geq c;c\in\mReal$.

\begin{mydef}[Kripke Structure Path]
A~path\cite{biere} $\rho_M=s_0,s_1,\dotsc$ starting at a~state
$s$ in the structure $M$ is an infinite sequence of states
$s_i, s = s_0$ such that
$\forall i \in \mNatural_0: (s_i, s_{i+1}) \in R$ which may be denoted
as $s_i\rightarrow s_{i+1}$, too. 
Furthermore, $\rho_M(i)=s_i$ is the $i$-th state on the path and
$\rho_M^i=s_i,s_{i+1},\dotsc$ denotes an endless suffix of states
starting at the position $i$.
\end{mydef}

\begin{mydef}[LTL Semantics]
Let $M$ be a~Kripke structure, $\rho_M$ path in $M$ and $\varphi$ be
an \textsc{ltl} formula. Then a relation $\rho_M\models\varphi$
($\varphi$ is valid along $\rho_M$) is defined as follows\cite{clarke}.
%\begin{inparaenum}[\upshape a\itshape)]
\begin{align}
	\rho_M\models p&\iff p\in L(\rho_M(0))\\
	\rho_M\models\neg p&\iff p\notin L(\rho_M(0))\\
	\rho_M\models \varphi\wedge\psi&\iff\rho_M\models\varphi\wedge
		\rho_M\models\psi\\
	\rho_M\models \varphi\vee\psi&\iff\rho_M\models\varphi\vee
		\rho_M\models\psi\\
	\rho_M\models\bG\varphi&\iff\forall i:\rho_M^i\models\varphi,
		i\in\mNatural\\
	\rho_M\models\bF\varphi&\iff\exists i:\rho_M^i\models\varphi,
		i\in\mNatural\\
	\rho_M\models\bX\varphi&\iff\rho_M^1\models\varphi\\
	\rho_M\models\varphi\bU\psi&\iff\exists i,i\in\mNatural_0:
		\rho_M^i\models\psi\wedge(\forall j,0\leq j\leq i:
			\rho_M^j\models\varphi)\\
	\rho_M\models\varphi\bR\psi&\iff\forall j,j\in\mNatural_0,
		\forall i,i<j:\rho_M^i\not\models\varphi\implies
			\rho_M^j\models\psi
\end{align}
%\end{inparaenum}
\end{mydef}

\begin{mydef}[Validity]
An \ltl formula $\varphi$ is universally valid in a~Kripke structure $M$
if $\rho_M\models\bA\varphi\iff\rho_M\models\varphi$ holds for all
paths wiht $\rho_M(0)\in S_0$.

An \ltl formula $\varphi$ is existentially valid in a~Kripke structure
$M$ if $\rho_M\models\bE\varphi\iff\rho_M\models\varphi$ holds for all
paths with $\rho_M(0)\in S_0$\cite{biere}.
\end{mydef}


Determining whether an \ltl formula $\varphi$ is existentially (resp.
universally) valid in a~given Kripke structure is called an
\emph{existential} (resp. an \emph{universal}) \emph{model checking}
problem\cite{biere}.

\subsection{Bounded Model Checking}
In case of bounded model checking one consideres a~prefix of the path
$\rho_M$, $k\in\mNatural$ symbols long that is sufficient as a~witness
in case of existential problem\cite{biere}. Intuitively, if all
possible prefixes are checked, the method is equal to common \ltl model
checking approaches. Thus, if \ltl is considered, there is an upper
limit $k=|2^{AP}|$ of the counterexample length\cite{biere}. However, in
special case of a~\emph{lasso-shaped} path, a~smaller bound $k=|AP^2|$
exists\cite{biere}. Below, the semantics of bounded model checking is
introduced.

\subsubsection*{Bounded Semantics}
The idea of finding a~counterexample lies in unrolling temporal
operators in a~formula $\varphi$ to get a~formula $\phi$ comprising
of first order logic operators and original atomic propositions
``attached'' to a~particular position in $\rho_M$.

In bounded model checking, one uses only first $k+1$ elements of
a~path $\rho_M$ to determine the validity of the formula along the
path\cite{biere}.

If a~path is a~$k$-loop, the standard semantics of \ltl is maintained --
for the definition, see again\cite{biere}. The $\models$ operator gets
an index $\models_k$ to denote the bound.

In case of an acyclic path, the $\models$ operator is redefined to
$\models_k^i$ where the $i$ means a~\emph{position in the prefix} to
consider. Moreover, the \ltl operator $\bG$ is always false as nothing
repeats in $\rho_M$ making it impossible to be decided. For semantics
of other \ltl operators over a~finite path see once more\cite{biere}.

As far as the translation from $\varphi$ to $\phi$ is considered,
only the acyclic part is introduced here for the
sake of brevity. Both the acyclic and loop definitions are due to
Biere et al\cite{biere}.

\begin{mydef}[LTL Formula Translation without a Loop]
For an LTL formula $\varphi$ and $i,j,k\in\mNatural$, with $i\leq k$ and
$p\in {AP}_\varphi$, ${AP}_\varphi$ being the set of atomic propositions
of $\varphi$
\begin{align}
	[[p]]_k^i&\rightarrow p(s_i)\\
	[[\neg p]]_k^i&\rightarrow\neg(p(s_i))\\
	[[\varphi\wedge\psi]]_k^i&\rightarrow
		[[\varphi]]_k^i\wedge[[\psi]]_k^i\\
	[[\varphi\vee\psi]]_k^i&\rightarrow
		[[\varphi]]_k^i\vee[[\psi]]_k^i\\
	[[\bX\varphi]]_k^i&\rightarrow[[\varphi]]_k^{i+1}\\
	[[\bG\varphi]]_k^i&\rightarrow\bot\\
	[[\bF\varphi]]_k^i&\rightarrow\bigvee_{j=i}^k[[\varphi]]_k^j\\
	[[\varphi\bU\psi]]_k^i&\rightarrow\bigvee_{j=i}^k\left(
		[[\psi]]_k^j\wedge\bigwedge_{n=i}^{j-i}[[\varphi]]_k^n
	\right)\\
	[[\varphi\bR\psi]]_k^i&\rightarrow\bigvee_{j=i}^k\left(
		[[\varphi]]_k^j\wedge\bigwedge_{n=i}^j[[\psi]]_n^k
	\right)
\end{align} 
\end{mydef}
However, the definition being recursive, it is very unefficient to
apply the $[[\cdot]]_k^i$ operator every time as the procedure would
make exponentially many operations with regard to $k$ in that case.
Instead, one has to utilize sub-formula sharing to improve the
performance to a~polynomial time\cite{biere}.

\chapter{Metodology}
\section{Filter}
The key feature is the equivalence of trace points based on atomic
propositions validity. For that purpose, the relation $\sim$ is defined.
It legitimates the filtering of a~trace. Interestingly,
a~filtered trace resembles very closely what was previously defined as
a kripke structure path. Therefore $\sim$ allows \ltl model checking
to be applied to traces as it removes the stuttering from
them\cite{lamport}.
\begin{mydef}[Point Equivalence]
Points $p_i,p_j\in\pi$ are equivalent in $\sim$ if and only if following
condition holds.
\begin{align}
	p_i\sim p_j	\overset{def}{\iff}&\forall a\in AP:
		\bigwedge_{q\in\Omega(p_i,p_j)}a(p_i)\iff a(q)\\
\Omega(p_i,p_j)=&\{q\mid p_i\rightarrow\dotsm\rightarrow q
		\rightarrow\dotsm\rightarrow p_j\}\cup\nonumber\\
		&\{q\mid p_j\rightarrow\dotsm\rightarrow q\rightarrow\dotsm
		\rightarrow p_i\}\cup\nonumber\\
		&\{p_i,p_j\}
%\end{equation}
\end{align}
\end{mydef}
In words, two points $p_i,p_j\in\pi$ are in relation $p_i\sim p_j$ if
they have got the same evaluation in all the atomic propositions while
so do all the points laying ``between'' $p_i$ and $p_j$.
\begin{mylemma}
Point equivalence $\sim$ is a~proper equivalence.
\begin{proof}Given a~trace $\pi$ and points $p_i,p_j,p_k\in\pi$,
following properties of $\sim$ are fulfiled rendering it a~proper
equivalence.
	\begin{inparaenum}
		\item{Reflexivity.} As $\Omega(p_i,p_i)=\{p_i\}$,
			reflexivity holds.
		\item{Symmetry.} Without lost of generality, let $p_i\sim p_j$
			but $p_j\not\sim p_i$. From $p_j\not\sim p_i$,
			$\exists a\in AP,q\in\Omega(p_j, p_i):\neg(a(p_j)
			\iff a(q))$. However, $\Omega(p_j, p_i)=\Omega(p_i,p_j)$
			and from the definition of $\sim$ and the fact that
			$p_i\sim p_j$,
			$\forall a\in AP:\bigwedge_{q\in\Omega(p_j,p_i)}a(p_j)\iff
			a(q)$, what is a~contradiction. Therefore, symmetry holds.
		\item{Transitivity.} Let $i\leq j\leq k$ and $p_i\sim p_j$,
			$p_j\sim p_k$ but $p_i\not\sim p_k$. By $p_i\not\sim p_k$,
			$\exists a\in AP, q\in\Omega(p_i, p_k):
			\neg(a(p_i)\iff a(q))$. By
			$\Omega(p_i,p_j)\cup\Omega(p_j,p_k)=\Omega(p_i,p_k)$ and by
			$p_i\sim p_j\wedge p_j\sim p_k$,
			$\forall a\in AP:\bigwedge_{q\in\Omega(p_i,p_k)}a(q)
			\iff a(p_k)$, what is a~contradiction. For other cases of
			$i,j,k$ ordering -- by means of $\sim$~symmetry --
			transitivity holds, too.
	\end{inparaenum}
	\qedhere
\end{proof}
\end{mylemma}
As a~consequence, $\sim$~partitions a~trace $\pi$ into
(infinitelly many) classes of points having the same evaluation in all
atomic propositions while remaining a~continuous sequence. Selecting
only the representants of particular classes, one is able to forget
other class points for the purpose of propositions validity checking
as they don't change it. It is useful especially for processing
finite sequences produced by numeric methods as plenty of resources can
be saved this way. Therefore, the implementation verifies only the
representants. These are selected as the first -- by means of
the $\rightarrow$ relation -- elements $q$ such that
$p\rightarrow q\wedge[p]\neq[q]$.

\section{Cycle Detection}
Recalling the $k$-loop definition and refering to the bounded model
checking, it is possible to argue about properties containing the $\bG$
operator even on finite-element traces\cite{biere}. For that purpose,
the prototype comprises two cycle detector implementations and compares
key aspects of both of them. Before that, here is some background about
the trace looping.

Even though it would be possible -- and more accurate -- to check
a~trace for loop presence directly on evaluated states, it wouldn't
work on spiral paths. As an example situation, condsider a 2D spiral
trace which has a point equilibirium in $x',y'$ and an \ltl property
$\bF((x\ge x'-\epsilon_x)\wedge(x\le x'+\epsilon_x))\wedge
\bF((y\ge y'-\epsilon_y)\wedge(y\le y'+\epsilon_y))$ checking this
equilibrium with some explicit inaccuracy $\epsilon_x,\epsilon_y$.
As the evaluation vector repeats in this case three times till
it reaches the equlibrium, the first repetition is labeled as a~cycle.
The cycle effectivelly blocking the rest of the trace to be inspected
renders the obviously true property invalid. See the
figure \ref{spiral}.
\begin{figure}
\input{spiral}
\caption{Spiral Equilibrium Property}
\label{spiral}
\end{figure}
Therefore, cycles are being detected on the trace values directly.
However, even this approach has got its drawbacks. One of them
is the comparision inacurracy, other the fact that a~dense spiral might
be considered a cycle even though it wasn't. Moreover, even filtered
(dense) spiral traces might comprise a~huge amount of point classes
making the bounded model checking approach impracticable.

On the other hand, if the filtered trace contains a~real limit cycle,
the sequence of evaluated states creates a~lasso-shape making the
bounded model checking approach run in $O(|AP|^2)$ of steps
instead of $O(2^{|AP|})$\cite{biere}. For that purpose, the bound is
determined as the loop property or the filtered trace lengt in case
no limit loop is present.

A~self-loop in a~trace requires special handling as well. In case of
a~trace with a~point equilibrium, the cycle detector has to cooperate
with the numeric method such that the lost of precision related to
approaching the equlibrium is reported as a~self-loop. Othervise,
detecting a~self-loop on filtered trace is impossible because the
approaching doesn't trigger a~change in atomic proposition evaluation.
In case an infinitely long discrete trace comprises only a~finite number
of distinct points, it contains a~cycle. Such a~situation might be
denoted as follows\cite{biere}.


\end{document}
