\documentclass[12pt,oneside,draft]{fithesis}
\usepackage{etex}
%\reserveinserts{128}

\usepackage[plainpages=false, pdfpagelabels]{hyperref}
%\usepackage{amssym}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{paralist}
%\usepackage{m-pictex}
%\usepackage{color}
\usepackage[chapter]{algorithm}
\usepackage{program}
\usepackage[numbers]{natbib}


%
\newcommand{\ltl}{\textsc{ltl}~}
\newcommand{\Next}{\emph{Next}~}
\newcommand{\mM}{\mathcal{M}}
\newcommand{\mD}{\mathcal{D}}
\newcommand{\mC}{\mathcal{C}}
\newcommand{\mI}{\mathcal{I}}
\newcommand{\mE}{\mathcal{E}}
\newcommand{\mS}{\mathcal{S}}
\newcommand{\mReal}{\mathbb{R}}
\newcommand{\mNatural}{\mathbb{N}}
\newcommand{\mTime}{\mathbb{T}}
\newcommand{\dStateVariables}{$Y'=\{y'_0,y'_1,\dotsc,y'_n\},n\in\mNatural$}
\newcommand{\dAtomicPropositionsI}{$AP_i=\{a_{i,0},a_{i,1},\dotsc,a_{i,m}\},m\in\mNatural$}
\newcommand{\bF}{\mathbf{F}}
\newcommand{\bG}{\mathbf{G}}
\newcommand{\bX}{\mathbf{X}}
\newcommand{\bU}{\mathbf{U}}
\newcommand{\bR}{\mathbf{R}}
\newcommand{\bA}{\mathbf{A}}
\newcommand{\bE}{\mathbf{E}}
%
\newtheorem{mydef}{Definition}
\newtheorem{mylemma}{Lemma}
%
\hyphenation{Kri-p-ke}
\hyphenation{boun-ded}
%\hyphenation{pro-po-si-t-ion}
%
\thesistitle{Simulation Analysis of Large-scale Dynamic Systems}
\thesissubtitle{Bachelors Thesis}
\thesisstudent{Milan Kov\'{a}\v{c}ik}
\thesiswoman{false}
\thesisfaculty{fi}
\thesisyear{Fall 2011}
\thesislang{en}
\thesisadvisor{David \v{S}afr\'{a}nek}
%
\input{transfig}
\begin{document}

\FrontMatter
\ThesisTitlePage

\begin{ThesisDeclaration}
\DeclarationText
\AdvisorName
\end{ThesisDeclaration}

%\begin{ThesisThanks}
%\end{ThesisThanks}

%\begin{ThesisAbstract}
%\end{ThesisAbstract}

%\begin{ThesisKeyWords}
%\end{ThesisKeyWords}

\MainMatter
\tableofcontents
\chapter{Introduction}
%\section{Framework Description}
The framework main task is to select traces starting at the seeds of
initial conditions that fulfil given \ltl specification over the time
period provided. Therefore two main components are identified:
\em simulation and model checking\rm{}.
In the framework, the output of the simulation is processed by the
model checking component to verify the LTL formula validity of
a particular trace. Having verified all traces of the initial conditions
set, the framework marks the seeds fulfiling the formula to provide
the user with an output. User then could refine her initial conditions
specification for further system evaluation. In this fashion, the user
might iterate till a~subjective satisfaction with the system evaluation
was reached.

In such a~session, the framework provides simulation traces of the
system observed over the time specified. The simulation being rather
straightforward, a~common integrator -- such as provided in the
\textsc{lsode} \cite{lsode} package -- may be used.
An output in this case is an approximation of a~continuous trajectory
of the dynamic system.

\chapter{Background}
Considering the model checking and simulation topics, this section
introduces necessary concepts utilized troughout the text.

\section{Trace}
Here, a~trace $\pi$ represents result of either a~dynamic system
evolution over a~range of time\cite{sven}\cite{pospisil} approximated by
a~numeric method or a~result of any other kind of experiment.
Both sources describing values of concentrations of $n$ state variables,
the domain considered is~$\mReal_{+}^n$.

\begin{mydef}[Trace]
Let $n\in\mNatural$ be the number of state variables $x_i$ of a~system,
then:
\begin{inparaenum}[\upshape a\itshape)]
\item a~sequence $\pi=p_0,p_1,\dotsc$ of tuples
$p_i\equiv(x_1,x_2,\dotsc,x_n)\in~\mReal_{+}^n$ is caled a~trace;
\item single element $p_i=\pi(i)$ of a~trace $\pi$ is
called a~point;
\item the first point in a~trace $p_0=\pi(0)$ is called
a~seed;
\item a suffix of points $p_i,p_{i+1},\dotsc$ of a~trace is
denoted $\pi^i$;
\item a~fact that $p_i$ predeceases $p_{i+1}$ in a~trace is
denoted~$p_i\rightarrow p_{i+1}$.
\end{inparaenum}
\end{mydef}

As far as dynamic systems are concerned, their evolution approximation
obtained as a~result of a~numerical method is always \emph{discrete and
finite}. The same holds for sampled real-life system experiments.
Moreover, these systems being deterministic\cite{sven}, only
deterministic models are considered troughout the text.

\section{Trace Properties}
Real-life deterministic system traces may be either \emph{divergent} --
in which case a~system generates just an infinite sequence of points --
or \emph{convergent}. In~the convergent case, two situations are
possible; a~point \emph{equilibrium} and a~\emph{limit cycle}. As far as
the point equilibrium is considered, a~system may reach it either
asymptotically or sliding downwards a~spiral. Similarily, the limit
cycle too behaves as an \emph{attractor}. These situations are depicted
in figure \ref{fig:trace:kinds}.

From the qualitative point of view, convergent traces express
\emph{liveness} and \emph{reachability} properties whereas
divergent traces allow only reachability properties to emerge.
To name some representants of these wider quality classes,
attractors and  \emph{invariance} are examples of liveness
properties whereas \emph{inevitability} and \emph{response} represent
the reachability class\cite{rizk}. What these have in common is they
can be expressed as \ltl formulae over real-based
constraints\cite{sven}. Therefore, the \ltl semantics is introduced.

\section{LTL Semantics}
A~Kripke structure is a~common way of modeling a~system for the purpose
of property validation\cite{clarke}.
\begin{mydef}[Kripke Structure]
Let ${AP}$ be a set of atomic propositions.
A~Kripke structure\cite{clarke} $M$ over $AP$ is a~tuple
$M=(S, S_0, R, L)$ where
\begin{inparaenum}[\upshape a\itshape)]
	\item{}$S$ is~a finite set of states;
	\item{}$S_0\subseteq{}S$ is the set of initial states;
	\item{}$R\subseteq{}S\times{}S$ is a~total transition relation; and
	\item{}$L:S\rightarrow{}2^{AP}$ is a~function that labels each state
		with a subset of atomic propositions valid in that state.
\end{inparaenum}
\end{mydef}
In the text, real-constraint atomic propositions are considered.
An example of such a~constraint could be
$a\in AP;a\equiv x_i \geq c;c\in\mReal$, where $x_i$ represents a~state
variable value.

The \ltl semantics being defined over a~kripke structure path, following
is the path definition\cite{clarke}.
\begin{mydef}[Kripke Structure Path]
A~path\cite{biere} $\rho_M=s_0,s_1,\dotsc$ starting at a~state
$s_0\in S_0$ in the structure $M$ is an infinite sequence of states
$s_i$ such that $\forall i \in \mNatural_0: (s_i, s_{i+1}) \in R$
which may be denoted $s_i\rightarrow s_{i+1}$, too. 
Furthermore, $\rho_M(i)=s_i$ is the $i$-th state on the path and
$\rho_M^i=s_i,s_{i+1},\dotsc$ denotes an endless suffix of states
starting at the position $i$.
\end{mydef}

\begin{mydef}[LTL Semantics]
Let $M$ be a~Kripke structure, $\rho_M$ path in $M$ and $\varphi$ be
an \textsc{ltl} formula. Then a relation $\rho_M\models\varphi$
($\varphi$ is valid along $\rho_M$) is defined as follows\cite{clarke}.
%\begin{inparaenum}[\upshape a\itshape)]
\begin{align}
	\rho_M\models p&\iff p\in L(\rho_M(0))\\
	\rho_M\models\neg p&\iff p\notin L(\rho_M(0))\\
	\rho_M\models \varphi\wedge\psi&\iff\rho_M\models\varphi\wedge
		\rho_M\models\psi\\
	\rho_M\models \varphi\vee\psi&\iff\rho_M\models\varphi\vee
		\rho_M\models\psi\\
	\rho_M\models\bG\varphi&\iff\forall i:\rho_M^i\models\varphi,
		i\in\mNatural\\
	\rho_M\models\bF\varphi&\iff\exists i:\rho_M^i\models\varphi,
		i\in\mNatural\\
	\rho_M\models\bX\varphi&\iff\rho_M^1\models\varphi\\
	\rho_M\models\varphi\bU\psi&\iff\exists i,i\in\mNatural_0:
		\rho_M^i\models\psi\wedge(\forall j,0\leq j\leq i:
			\rho_M^j\models\varphi)\\
	\rho_M\models\varphi\bR\psi&\iff\forall j,j\in\mNatural_0,
		\forall i,i<j:\rho_M^i\not\models\varphi\implies
			\rho_M^j\models\psi
\end{align}
%\end{inparaenum}
\end{mydef}

Here, the notion of \ltl formula validity with regards to a~kripke
structure path is introduced.
\begin{mydef}[Validity]
An \ltl formula $\varphi$ is universally valid in a~Kripke structure $M$
if $\rho_M\models\bA\varphi\iff\rho_M\models\varphi$ holds for all
paths wiht $\rho_M(0)~\in~S_0$.

An \ltl formula $\varphi$ is existentially valid in a~Kripke structure
$M$ if $\rho_M~\models~\bE~\varphi\iff\rho_M\models\varphi$ holds for
at least one path with $\rho_M(0)~\in~S_0$\cite{biere}.
\end{mydef}


Determining whether an \ltl formula $\varphi$ is existentially (resp.
universally) valid in a~given Kripke structure is called an
\emph{existential} (resp. an \emph{universal}) \emph{model checking}
problem\cite{biere}.

There are multiple ways how to verify \ltl formula validity over kripke
structure paths. For some structures -- especially those with
\emph{lasso-shaped} paths -- the bounded model checking is an effective
validation method \cite{biere}. Therefore, it is introduced as well.

\section{Bounded Model Checking}
The idea of bounded model checking stems from considering only a~prefix
of a~path to check formula validity. One way of doing it is ``unrolling''
temporal operators of the formula to get a~new formula comprising only
first order logic operators and original atomic propositions attached
to a~particular position on the path. Intuitively, if all possible
prefixes are checked, the method is equivalent to common \ltl model
checking approaches. If \ltl is considered, there is an upper
limit $k=|2^{AP}|$ of the counterexample length\cite{biere}. However, in
special case of a~\emph{lasso-shaped} path, a~smaller bound $k=|AP^2|$
exists\cite{biere}.

As far as the semantics is considered, boudned model checking
distinguishes between cyclic and acyclic paths. Therefore, the $k$-loop
definition follows.
\begin{mydef}[K-Loop]
For $l\leq k;l,k\in\mNatural_0$ a~path $\rho$ is called a~$(k,l)$-loop
if $\rho(k)\rightarrow\rho(l)$ and
$\rho=p_0,\dotsc,\overline{p_{l},\dotsc,p_{k},}$
A~$(k,l)$-loop may be called simply a~$k$-loop as well or, if $l=k$,
a~self-loop.
\end{mydef}
As $k$-loop and lasso-shaped path refer to the same path property, they
are used interchangeably in the text.

If a~path is a~$k$-loop, the standard semantics of \ltl is maintained,
whereas in case of an acyclic path, the \ltl operator $\bG$ is always
false as nothing repeats in $\rho_M$ making it intuitivelly impossible
to decide.

As far as the unrolling--translation is considered, only the cyclic part
is introduced here for the sake of brevity.
Both the clic translation and $k$-loop definitions are due to Biere
et al.
\begin{mydef}[Successor in a~Loop]
Let $k,l,i\in\mNatural_0$, with $l,i \leq k$. The successor $succ(i)$ is
defined as follows. $succ(i)=i+1$ if $i<k$ and $succ(i)=l$ otherwise.
\end{mydef}
\begin{mydef}[LTL Formula Translation with a Loop]
For an LTL formula $\varphi$ and $i,j,k\in\mNatural$, with $i\leq k$ and
$p\in {AP}_\varphi$, ${AP}_\varphi$ being the set of atomic propositions
of $\varphi$
\begin{align}
	[[p]]_k^i&\rightarrow p(s_i)\\
	[[\neg p]]_k^i&\rightarrow\neg(p(s_i))\\
	[[\varphi\wedge\psi]]_k^i&\rightarrow
		[[\varphi]]_k^i\wedge[[\psi]]_k^i\\
	[[\varphi\vee\psi]]_k^i&\rightarrow
		[[\varphi]]_k^i\vee[[\psi]]_k^i\\
\end{align}
\begin{align}
	[[\bX\varphi]]_k^i&\rightarrow[[\varphi]]_k^{i+1}\\
	[[\bG\varphi]]_k^i&\rightarrow\bot\\
	[[\bF\varphi]]_k^i&\rightarrow\bigvee_{j=i}^k[[\varphi]]_k^j\\
	[[\varphi\bU\psi]]_k^i&\rightarrow\bigvee_{j=i}^k\left(
		[[\psi]]_k^j\wedge\bigwedge_{n=i}^{j-i}[[\varphi]]_k^n
	\right)\\
	[[\varphi\bR\psi]]_k^i&\rightarrow\bigvee_{j=i}^k\left(
		[[\varphi]]_k^j\wedge\bigwedge_{n=i}^j[[\psi]]_n^k
	\right)
\end{align} 
\end{mydef}
However, the definition being recursive, it is very unefficient to
apply the $[[\cdot]]_k^i$ operator every time as the procedure would
make exponentially many operations with regard to $k$ in that case.
Instead, one has to utilize sub-formula sharing to improve the
performance to a~polynomial time when implementing\cite{biere}. In next
chapter, a~method is introduced describing how to utilize the bounded
model checking approach for real-life system traces.

\chapter{Metodology}
\section{Filter}
As far as real-life system approximation traces model checking
is considered, the crucial factor is the stuttering it inevitably
contains\cite{lamport}. To deal with this feature, a~filtering
is introduced which has two benefits -- it both relaxes the length of
a~trace as well as it justifies $\bX$ operator usage. The key here
is the equivalence of trace points based on atomic propositions
validity. For that purpose, the relation $\sim$ is defined over a~system
trace.
\begin{mydef}[Point Equivalence]
Points $p_i,p_j\in\pi$ are equivalent in $\sim$ if and only if following
condition holds.
\begin{align}
	p_i\sim p_j	\overset{def}{\iff}&\forall a\in AP:
		\bigwedge_{q\in\Omega(p_i,p_j)}a(p_i)\iff a(q)\\
\Omega(p_i,p_j)=&\{q\mid p_i\rightarrow\dotsm\rightarrow q
		\rightarrow\dotsm\rightarrow p_j\}\cup\nonumber\\
		&\{q\mid p_j\rightarrow\dotsm\rightarrow q\rightarrow\dotsm
		\rightarrow p_i\}\cup\nonumber\\
		&\{p_i,p_j\}
%\end{equation}
\end{align}
\end{mydef}
In words, two points $p_i,p_j\in\pi$ are in relation $p_i\sim p_j$ if
they have got the same evaluation in all the atomic propositions while
so do all the points laying ``between'' $p_i$ and $p_j$.
\begin{mylemma}
Point equivalence $\sim$ is a~proper equivalence.
\begin{proof}Given a~trace $\pi$ and points $p_i,p_j,p_k\in\pi$,
following properties of $\sim$ are fulfiled rendering it a~proper
equivalence.
	\begin{inparaenum}
		\item{Reflexivity.} As $\Omega(p_i,p_i)=\{p_i\}$,
			reflexivity holds.
		\item{Symmetry.} Without lost of generality, let $p_i\sim p_j$
			but $p_j\not\sim p_i$. From $p_j\not\sim p_i$,
			$\exists a\in AP,q\in\Omega(p_j, p_i):\neg(a(p_j)
			\iff a(q))$. However, $\Omega(p_j, p_i)=\Omega(p_i,p_j)$
			and from the definition of $\sim$ and the fact that
			$p_i\sim p_j$,
			$\forall a\in AP:\bigwedge_{q\in\Omega(p_j,p_i)}a(p_j)\iff
			a(q)$, what is a~contradiction. Therefore, symmetry holds.
		\item{Transitivity.} Let $i\leq j\leq k$ and $p_i\sim p_j$,
			$p_j\sim p_k$ but $p_i\not\sim p_k$. By $p_i\not\sim p_k$,
			$\exists a\in AP, q\in\Omega(p_i, p_k):
			\neg(a(p_i)\iff a(q))$. By
			$\Omega(p_i,p_j)\cup\Omega(p_j,p_k)=\Omega(p_i,p_k)$ and by
			$p_i\sim p_j\wedge p_j\sim p_k$,
			$\forall a\in AP:\bigwedge_{q\in\Omega(p_i,p_k)}a(q)
			\iff a(p_k)$, what is a~contradiction. For other cases of
			$i,j,k$ ordering -- by means of $\sim$~symmetry --
			transitivity holds, too.
	\end{inparaenum}
	\qedhere
\end{proof}
\end{mylemma}
As a~consequence, $\sim$~partitions a~trace $\pi$ into
(infinitelly many) classes of points having the same evaluation in all
atomic propositions while remaining a~continuous sequence. Selecting
only the representants of particular classes, one is able to forget
other class points for the purpose of propositions validity checking
as they don't change it. Following definition therefore introduces
the notion of a~filtered trace.
\begin{mydef}[Filtered Trace] Let $\pi=p_0,p_1,\dotsc$ be a~system
trace. A~filtered trace $\tilde{\pi}$ is a~sequence of partition
$\pi/_{\sim}$ classes representants
$\tilde{\pi}=\tilde{p}_0,\tilde{p}_1,\dotsc$ such that
\begin{align}
\tilde{p}_{0}=&p_0\\
\tilde{p}_{i}=&p_k:p_{k-1}\rightarrow p_{k},\nonumber\\
	&p_{k-1}\in[\tilde{p}_{i-1}]
	\wedge p_k\in[\tilde{p}_{i}];\nonumber\\
	&k,l\in\mNatural,p_k,p_{k-1}\in\pi.
\end{align}
Naturarlly, the arrow notation can be adopted for filtered traces, too;
the relation $\tilde{p}_{i-1}$ is a~predecessor of $\tilde{p}_{i}$ can
be denoted $\tilde{p}_{i-1}\rightarrow\tilde{p}_{i}$ as well.
\end{mydef}
In words, representants are selected as the first elements -- with
regards to the $\rightarrow$ relation -- belonging to different
partition classes. The usual notation $\tilde{\pi}(i),\tilde{\pi}^i$
applies here as well.

Given a~seed $p_0$, particular filtered trace rooted in this seed may be
considered a~kripke structure path with the labeling function returning
atomic propositions valid in particular trace point. For the bounded
model checking however the bound and cycle presence has to be checked.
These goals can be achieved by a~\emph{cycle detection} algorithm as
a~good bound for lasso-shaped as well as divergent traces is their
length possibly including the loop\cite{biere}. For the sake of brevity,
no cycle detection algorithm is introduced but
Brent's\cite{wloop,brent} has been adopted here.

\section{Cycle Detection}
%It is assumed that the $\sim$ relation holds even for cyclic
%traces\cite{biere}.

Even though it would be possible -- and more accurate -- to check
a~trace for loop presence directly on evaluated states, it wouldn't
work on spiral paths. As an example situation, condsider a~2D~spiral
trace which has a~point equilibirium in $x',y'$ and an \ltl property
$\bF((x\ge x'-\epsilon_x)\wedge(x\le x'+\epsilon_x))\wedge
\bF((y\ge y'-\epsilon_y)\wedge(y\le y'+\epsilon_y))$ checking this
equilibrium with some explicit inaccuracy $\epsilon_x,\epsilon_y$.
As the evaluation vector repeats in this case three times till
it reaches the equlibrium -- see the figure \ref{spiral} --  the first
repetition is labeled as a~cycle. The cycle effectivelly blocking the
rest of the inspected trace renders the obviously true property invalid.
Therefore, cycles are being detected on the trace values directly.
\begin{figure}
%\input{spiral}
\caption{Spiral Equilibrium Property}
\label{spiral}
\end{figure}

However, even this approach has got its drawbacks. One of them
is the comparision inacurracy causing a~cycle either being detected
after unnecessary looping or not at all. Other the fact that a~dense
spiral might be considered a cycle even though it wasn't. Moreover, even
filtered (dense) spiral traces might comprise a~huge amount of point
classes making the bounded model checking approach impracticable.

On the other hand, if the filtered trace contains a~real limit cycle,
the sequence of evaluated states creates a~lasso-shape making the
bounded model checking approach run in $O(|AP|^2)$ of steps
instead of $O(2^{|AP|})$\cite{biere}. For that purpose, the bound is
determined as the filtered trace length possibly including the loop, if
present.

A~self-loop in a~trace requires special handling as well. In case of
a~trace with a~point equilibrium, the cycle detector has to cooperate
with the numeric method such that the lost of precision related to
approaching the equlibrium is reported as a~self-loop. Othervise,
detecting a~self-loop on filtered trace is impossible because the
approaching doesn't trigger a~change in atomic proposition evaluation.


\section{Algorithm}
Considering above limitations, an algorithm comprising simulation,
filtering, cycle detection and bounded model checking is introduced.

Algorithm \ref{simulationCycleDetectFilter} houses the procedure of
the numeric method, cycle detector and filter. The input parameters are:
\begin{inparaenum}[\itshape a\upshape)]
	\item{$\varphi$} the \ltl formula to use for $\sim$ relation
		computation;
	\item{$p_0$} the seed to be used both with the $\sim$ and numeric
		method initialization; and
	\item{$k_{\omega}$} the maximal amount of steps the numeric method
		should take.
\end{inparaenum}

To simulate particular system, custom numeric method is utilized.
Trace points are generated until the integration performs $k_{\omega}$
steps. In each step, their presence in a~single $\sim$ partition class
is checked. If the class changes, new representant is identified
and is appended to the filtered trace.

As an equilibrium may be encountered only while points remain within
a~single class, the equilibrium property is checked in each numeric
method step. The integration precission lost is considered a~point
equilibrium case. In that event, a~self-loop on the last point is
reported.

In case a~limit cycle is encountered, the filtered trace is terminated
before steps count reaches the $k_{\omega}$ limit and cycle start is
repored in addition to the filtered trace length. Here, the memory-less
Brent's cycle detection algorithm is utilized\cite{wloop,brent}
-- only one point is needed to decide the cycle presence considering
proper detector initialization.

Worth mentioning, it is assumed that if a~cycle is detected over
a~filtered trace, a~cycle must be present in unfiltered trace, too.

\begin{figure}
\label{fig:trace:kinds}
\caption{Trace Kinds}
\end{figure}


\begin{algorithm}
	\caption{Simulation, Cycle Detection, Filter}
	\label{simulationCycleDetectFilter}
	\begin{program}
%		\BEGIN
			\PROC |Simulation|(\varphi, p_0, k_{\omega}) \BODY
			|Initialize numerics|(p_0);
			|Initialize|\sim|counting|(\varphi, p_0);
			|Initialize cycle detector|(p_0);
			k:=l:=0;
			p:=p_0;
			\tilde{\pi}:=p;
			steps:=1;
			\WHILE steps < k_{\omega}
			\DO
				\WHILE p\sim|numerics|(p) \wedge steps < k_{\omega}
				\DO
					p:=|numerics|(p);
					\IF |numeric precission lost|(p)\rcomment{equilibrium}
					\THEN
						l:=k;\rcomment{selfloop}
						\keyword{return}(\tilde{\pi},k,l);
					\FI
					steps:=steps+1;
				\OD
				\IF l:=|cycle detected|(p)\rcomment{limit cycle}
				\THEN
					\keyword{break};
				\FI
				\tilde{\pi}:=\tilde{\pi},p;
				k:=k+1;\rcomment{new representant}
			\OD
			\keyword{return}(\tilde{\pi},k,l);
			\ENDPROC
%		\END
	\end{program}
\end{algorithm}

The algorithm \ref{modelChecking} utilizes output of the Simulation
procedure and -- based on a~cycle presence -- performs the bounded
model checking formula unrolling of $\varphi$. The unrolled expression
is then applied to the filtered path to obtain a~true--false result.


\begin{algorithm}
	\caption{Model Checking}
	\label{modelChecking}
	\begin{program}
		\keyword{require}\:(\varphi,p_0,k_\omega);
		\BEGIN
			(\tilde{\pi},k,l):=|Simulation|(\varphi, p_0, k_\omega);
			\IF l \neq 0
			\THEN
				\keyword{return}({}_l[[\varphi]]_k^0(\tilde{\pi})) \rcomment{cyclic}
			\ELSE
				\keyword{return}([[\varphi]]_k^0(\tilde{\pi})) \rcomment{acyclic}
			\FI
		\END
	\end{program}
\end{algorithm}

\chapter{Evaluation}
In global, the procedure repeats for each trace seed considered while
the limit and the \ltl formula remain the same. Each trace then might
therefore\dots
\bibliographystyle{plainnat}
\bibliography{thesis}
\end{document}
\backmatter
